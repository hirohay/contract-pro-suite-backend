// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: operator_assignments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOperatorAssignment = `-- name: CreateOperatorAssignment :one
INSERT INTO operator_assignments (
    client_id,
    operator_id,
    role,
    status,
    assigned_at
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING client_id, operator_id, role, status, assigned_at, unassigned_at, deleted_at, deleted_by
`

type CreateOperatorAssignmentParams struct {
	ClientID   pgtype.UUID        `json:"client_id"`
	OperatorID pgtype.UUID        `json:"operator_id"`
	Role       string             `json:"role"`
	Status     string             `json:"status"`
	AssignedAt pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) CreateOperatorAssignment(ctx context.Context, arg CreateOperatorAssignmentParams) (OperatorAssignment, error) {
	row := q.db.QueryRow(ctx, createOperatorAssignment,
		arg.ClientID,
		arg.OperatorID,
		arg.Role,
		arg.Status,
		arg.AssignedAt,
	)
	var i OperatorAssignment
	err := row.Scan(
		&i.ClientID,
		&i.OperatorID,
		&i.Role,
		&i.Status,
		&i.AssignedAt,
		&i.UnassignedAt,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const deleteOperatorAssignment = `-- name: DeleteOperatorAssignment :exec
UPDATE operator_assignments
SET
    deleted_at = now(),
    deleted_by = $3
WHERE client_id = $1
  AND operator_id = $2
  AND deleted_at IS NULL
`

type DeleteOperatorAssignmentParams struct {
	ClientID   pgtype.UUID `json:"client_id"`
	OperatorID pgtype.UUID `json:"operator_id"`
	DeletedBy  pgtype.UUID `json:"deleted_by"`
}

func (q *Queries) DeleteOperatorAssignment(ctx context.Context, arg DeleteOperatorAssignmentParams) error {
	_, err := q.db.Exec(ctx, deleteOperatorAssignment, arg.ClientID, arg.OperatorID, arg.DeletedBy)
	return err
}

const getOperatorAssignment = `-- name: GetOperatorAssignment :one
SELECT client_id, operator_id, role, status, assigned_at, unassigned_at, deleted_at, deleted_by FROM operator_assignments
WHERE client_id = $1
  AND operator_id = $2
  AND deleted_at IS NULL
`

type GetOperatorAssignmentParams struct {
	ClientID   pgtype.UUID `json:"client_id"`
	OperatorID pgtype.UUID `json:"operator_id"`
}

func (q *Queries) GetOperatorAssignment(ctx context.Context, arg GetOperatorAssignmentParams) (OperatorAssignment, error) {
	row := q.db.QueryRow(ctx, getOperatorAssignment, arg.ClientID, arg.OperatorID)
	var i OperatorAssignment
	err := row.Scan(
		&i.ClientID,
		&i.OperatorID,
		&i.Role,
		&i.Status,
		&i.AssignedAt,
		&i.UnassignedAt,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const getOperatorAssignmentsByClientID = `-- name: GetOperatorAssignmentsByClientID :many
SELECT client_id, operator_id, role, status, assigned_at, unassigned_at, deleted_at, deleted_by FROM operator_assignments
WHERE client_id = $1
  AND deleted_at IS NULL
ORDER BY assigned_at DESC
`

func (q *Queries) GetOperatorAssignmentsByClientID(ctx context.Context, clientID pgtype.UUID) ([]OperatorAssignment, error) {
	rows, err := q.db.Query(ctx, getOperatorAssignmentsByClientID, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperatorAssignment{}
	for rows.Next() {
		var i OperatorAssignment
		if err := rows.Scan(
			&i.ClientID,
			&i.OperatorID,
			&i.Role,
			&i.Status,
			&i.AssignedAt,
			&i.UnassignedAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperatorAssignmentsByOperatorID = `-- name: GetOperatorAssignmentsByOperatorID :many
SELECT client_id, operator_id, role, status, assigned_at, unassigned_at, deleted_at, deleted_by FROM operator_assignments
WHERE operator_id = $1
  AND deleted_at IS NULL
  AND status = 'ACTIVE'
ORDER BY assigned_at DESC
`

func (q *Queries) GetOperatorAssignmentsByOperatorID(ctx context.Context, operatorID pgtype.UUID) ([]OperatorAssignment, error) {
	rows, err := q.db.Query(ctx, getOperatorAssignmentsByOperatorID, operatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperatorAssignment{}
	for rows.Next() {
		var i OperatorAssignment
		if err := rows.Scan(
			&i.ClientID,
			&i.OperatorID,
			&i.Role,
			&i.Status,
			&i.AssignedAt,
			&i.UnassignedAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOperatorAssignment = `-- name: UpdateOperatorAssignment :one
UPDATE operator_assignments
SET
    role = COALESCE($3, role),
    status = COALESCE($4, status),
    unassigned_at = COALESCE($5, unassigned_at)
WHERE client_id = $1
  AND operator_id = $2
  AND deleted_at IS NULL
RETURNING client_id, operator_id, role, status, assigned_at, unassigned_at, deleted_at, deleted_by
`

type UpdateOperatorAssignmentParams struct {
	ClientID     pgtype.UUID        `json:"client_id"`
	OperatorID   pgtype.UUID        `json:"operator_id"`
	Role         string             `json:"role"`
	Status       string             `json:"status"`
	UnassignedAt pgtype.Timestamptz `json:"unassigned_at"`
}

func (q *Queries) UpdateOperatorAssignment(ctx context.Context, arg UpdateOperatorAssignmentParams) (OperatorAssignment, error) {
	row := q.db.QueryRow(ctx, updateOperatorAssignment,
		arg.ClientID,
		arg.OperatorID,
		arg.Role,
		arg.Status,
		arg.UnassignedAt,
	)
	var i OperatorAssignment
	err := row.Scan(
		&i.ClientID,
		&i.OperatorID,
		&i.Role,
		&i.Status,
		&i.AssignedAt,
		&i.UnassignedAt,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
