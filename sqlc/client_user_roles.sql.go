// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: client_user_roles.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createClientUserRole = `-- name: CreateClientUserRole :one
INSERT INTO client_user_roles (
    client_id,
    client_user_id,
    role_id,
    assigned_at
) VALUES (
    $1, $2, $3, $4
)
RETURNING client_id, client_user_id, role_id, assigned_at, revoked_at, deleted_at, deleted_by
`

type CreateClientUserRoleParams struct {
	ClientID     pgtype.UUID        `json:"client_id"`
	ClientUserID pgtype.UUID        `json:"client_user_id"`
	RoleID       pgtype.UUID        `json:"role_id"`
	AssignedAt   pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) CreateClientUserRole(ctx context.Context, arg CreateClientUserRoleParams) (ClientUserRole, error) {
	row := q.db.QueryRow(ctx, createClientUserRole,
		arg.ClientID,
		arg.ClientUserID,
		arg.RoleID,
		arg.AssignedAt,
	)
	var i ClientUserRole
	err := row.Scan(
		&i.ClientID,
		&i.ClientUserID,
		&i.RoleID,
		&i.AssignedAt,
		&i.RevokedAt,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const deleteClientUserRole = `-- name: DeleteClientUserRole :exec
UPDATE client_user_roles
SET
    deleted_at = now(),
    deleted_by = $4
WHERE client_id = $1
  AND client_user_id = $2
  AND role_id = $3
  AND deleted_at IS NULL
`

type DeleteClientUserRoleParams struct {
	ClientID     pgtype.UUID `json:"client_id"`
	ClientUserID pgtype.UUID `json:"client_user_id"`
	RoleID       pgtype.UUID `json:"role_id"`
	DeletedBy    pgtype.UUID `json:"deleted_by"`
}

func (q *Queries) DeleteClientUserRole(ctx context.Context, arg DeleteClientUserRoleParams) error {
	_, err := q.db.Exec(ctx, deleteClientUserRole,
		arg.ClientID,
		arg.ClientUserID,
		arg.RoleID,
		arg.DeletedBy,
	)
	return err
}

const getClientUserRole = `-- name: GetClientUserRole :one
SELECT client_id, client_user_id, role_id, assigned_at, revoked_at, deleted_at, deleted_by FROM client_user_roles
WHERE client_id = $1
  AND client_user_id = $2
  AND role_id = $3
  AND deleted_at IS NULL
`

type GetClientUserRoleParams struct {
	ClientID     pgtype.UUID `json:"client_id"`
	ClientUserID pgtype.UUID `json:"client_user_id"`
	RoleID       pgtype.UUID `json:"role_id"`
}

func (q *Queries) GetClientUserRole(ctx context.Context, arg GetClientUserRoleParams) (ClientUserRole, error) {
	row := q.db.QueryRow(ctx, getClientUserRole, arg.ClientID, arg.ClientUserID, arg.RoleID)
	var i ClientUserRole
	err := row.Scan(
		&i.ClientID,
		&i.ClientUserID,
		&i.RoleID,
		&i.AssignedAt,
		&i.RevokedAt,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const getClientUserRolesByRoleID = `-- name: GetClientUserRolesByRoleID :many
SELECT client_id, client_user_id, role_id, assigned_at, revoked_at, deleted_at, deleted_by FROM client_user_roles
WHERE client_id = $1
  AND role_id = $2
  AND deleted_at IS NULL
  AND revoked_at IS NULL  -- 有効なロールのみ
ORDER BY assigned_at DESC
`

type GetClientUserRolesByRoleIDParams struct {
	ClientID pgtype.UUID `json:"client_id"`
	RoleID   pgtype.UUID `json:"role_id"`
}

func (q *Queries) GetClientUserRolesByRoleID(ctx context.Context, arg GetClientUserRolesByRoleIDParams) ([]ClientUserRole, error) {
	rows, err := q.db.Query(ctx, getClientUserRolesByRoleID, arg.ClientID, arg.RoleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ClientUserRole{}
	for rows.Next() {
		var i ClientUserRole
		if err := rows.Scan(
			&i.ClientID,
			&i.ClientUserID,
			&i.RoleID,
			&i.AssignedAt,
			&i.RevokedAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientUserRolesByUserID = `-- name: GetClientUserRolesByUserID :many
SELECT client_id, client_user_id, role_id, assigned_at, revoked_at, deleted_at, deleted_by FROM client_user_roles
WHERE client_id = $1
  AND client_user_id = $2
  AND deleted_at IS NULL
  AND revoked_at IS NULL  -- 有効なロールのみ
ORDER BY assigned_at DESC
`

type GetClientUserRolesByUserIDParams struct {
	ClientID     pgtype.UUID `json:"client_id"`
	ClientUserID pgtype.UUID `json:"client_user_id"`
}

func (q *Queries) GetClientUserRolesByUserID(ctx context.Context, arg GetClientUserRolesByUserIDParams) ([]ClientUserRole, error) {
	rows, err := q.db.Query(ctx, getClientUserRolesByUserID, arg.ClientID, arg.ClientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ClientUserRole{}
	for rows.Next() {
		var i ClientUserRole
		if err := rows.Scan(
			&i.ClientID,
			&i.ClientUserID,
			&i.RoleID,
			&i.AssignedAt,
			&i.RevokedAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeClientUserRole = `-- name: RevokeClientUserRole :exec
UPDATE client_user_roles
SET
    revoked_at = now()
WHERE client_id = $1
  AND client_user_id = $2
  AND role_id = $3
  AND deleted_at IS NULL
  AND revoked_at IS NULL
`

type RevokeClientUserRoleParams struct {
	ClientID     pgtype.UUID `json:"client_id"`
	ClientUserID pgtype.UUID `json:"client_user_id"`
	RoleID       pgtype.UUID `json:"role_id"`
}

func (q *Queries) RevokeClientUserRole(ctx context.Context, arg RevokeClientUserRoleParams) error {
	_, err := q.db.Exec(ctx, revokeClientUserRole, arg.ClientID, arg.ClientUserID, arg.RoleID)
	return err
}
