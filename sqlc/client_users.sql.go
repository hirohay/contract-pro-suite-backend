// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: client_users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createClientUser = `-- name: CreateClientUser :one
INSERT INTO client_users (
    client_user_id,
    client_id,
    email,
    first_name,
    last_name,
    department,
    position,
    settings,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING client_user_id, client_id, email, first_name, last_name, department, position, settings, status, deleted_at, deleted_by, created_at, updated_at
`

type CreateClientUserParams struct {
	ClientUserID pgtype.UUID `json:"client_user_id"`
	ClientID     pgtype.UUID `json:"client_id"`
	Email        string      `json:"email"`
	FirstName    string      `json:"first_name"`
	LastName     string      `json:"last_name"`
	Department   pgtype.Text `json:"department"`
	Position     pgtype.Text `json:"position"`
	Settings     []byte      `json:"settings"`
	Status       string      `json:"status"`
}

func (q *Queries) CreateClientUser(ctx context.Context, arg CreateClientUserParams) (ClientUser, error) {
	row := q.db.QueryRow(ctx, createClientUser,
		arg.ClientUserID,
		arg.ClientID,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Department,
		arg.Position,
		arg.Settings,
		arg.Status,
	)
	var i ClientUser
	err := row.Scan(
		&i.ClientUserID,
		&i.ClientID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Department,
		&i.Position,
		&i.Settings,
		&i.Status,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteClientUser = `-- name: DeleteClientUser :exec
UPDATE client_users
SET
    deleted_at = now(),
    deleted_by = $3,
    updated_at = now()
WHERE client_user_id = $1
  AND client_id = $2
  AND deleted_at IS NULL
`

type DeleteClientUserParams struct {
	ClientUserID pgtype.UUID `json:"client_user_id"`
	ClientID     pgtype.UUID `json:"client_id"`
	DeletedBy    pgtype.UUID `json:"deleted_by"`
}

func (q *Queries) DeleteClientUser(ctx context.Context, arg DeleteClientUserParams) error {
	_, err := q.db.Exec(ctx, deleteClientUser, arg.ClientUserID, arg.ClientID, arg.DeletedBy)
	return err
}

const getClientUser = `-- name: GetClientUser :one
SELECT client_user_id, client_id, email, first_name, last_name, department, position, settings, status, deleted_at, deleted_by, created_at, updated_at FROM client_users
WHERE client_user_id = $1
  AND client_id = $2
  AND deleted_at IS NULL
`

type GetClientUserParams struct {
	ClientUserID pgtype.UUID `json:"client_user_id"`
	ClientID     pgtype.UUID `json:"client_id"`
}

func (q *Queries) GetClientUser(ctx context.Context, arg GetClientUserParams) (ClientUser, error) {
	row := q.db.QueryRow(ctx, getClientUser, arg.ClientUserID, arg.ClientID)
	var i ClientUser
	err := row.Scan(
		&i.ClientUserID,
		&i.ClientID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Department,
		&i.Position,
		&i.Settings,
		&i.Status,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientUserByEmail = `-- name: GetClientUserByEmail :one
SELECT client_user_id, client_id, email, first_name, last_name, department, position, settings, status, deleted_at, deleted_by, created_at, updated_at FROM client_users
WHERE client_id = $1
  AND email = $2
  AND deleted_at IS NULL
`

type GetClientUserByEmailParams struct {
	ClientID pgtype.UUID `json:"client_id"`
	Email    string      `json:"email"`
}

func (q *Queries) GetClientUserByEmail(ctx context.Context, arg GetClientUserByEmailParams) (ClientUser, error) {
	row := q.db.QueryRow(ctx, getClientUserByEmail, arg.ClientID, arg.Email)
	var i ClientUser
	err := row.Scan(
		&i.ClientUserID,
		&i.ClientID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Department,
		&i.Position,
		&i.Settings,
		&i.Status,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientUserByUserIDOnly = `-- name: GetClientUserByUserIDOnly :one
SELECT client_user_id, client_id, email, first_name, last_name, department, position, settings, status, deleted_at, deleted_by, created_at, updated_at FROM client_users
WHERE client_user_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetClientUserByUserIDOnly(ctx context.Context, clientUserID pgtype.UUID) (ClientUser, error) {
	row := q.db.QueryRow(ctx, getClientUserByUserIDOnly, clientUserID)
	var i ClientUser
	err := row.Scan(
		&i.ClientUserID,
		&i.ClientID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Department,
		&i.Position,
		&i.Settings,
		&i.Status,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listClientUsers = `-- name: ListClientUsers :many
SELECT client_user_id, client_id, email, first_name, last_name, department, position, settings, status, deleted_at, deleted_by, created_at, updated_at FROM client_users
WHERE client_id = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListClientUsersParams struct {
	ClientID pgtype.UUID `json:"client_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListClientUsers(ctx context.Context, arg ListClientUsersParams) ([]ClientUser, error) {
	rows, err := q.db.Query(ctx, listClientUsers, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ClientUser{}
	for rows.Next() {
		var i ClientUser
		if err := rows.Scan(
			&i.ClientUserID,
			&i.ClientID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Department,
			&i.Position,
			&i.Settings,
			&i.Status,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClientUser = `-- name: UpdateClientUser :one
UPDATE client_users
SET
    email = COALESCE($3, email),
    first_name = COALESCE($4, first_name),
    last_name = COALESCE($5, last_name),
    department = COALESCE($6, department),
    position = COALESCE($7, position),
    settings = COALESCE($8, settings),
    status = COALESCE($9, status),
    updated_at = now()
WHERE client_user_id = $1
  AND client_id = $2
  AND deleted_at IS NULL
RETURNING client_user_id, client_id, email, first_name, last_name, department, position, settings, status, deleted_at, deleted_by, created_at, updated_at
`

type UpdateClientUserParams struct {
	ClientUserID pgtype.UUID `json:"client_user_id"`
	ClientID     pgtype.UUID `json:"client_id"`
	Email        string      `json:"email"`
	FirstName    string      `json:"first_name"`
	LastName     string      `json:"last_name"`
	Department   pgtype.Text `json:"department"`
	Position     pgtype.Text `json:"position"`
	Settings     []byte      `json:"settings"`
	Status       string      `json:"status"`
}

func (q *Queries) UpdateClientUser(ctx context.Context, arg UpdateClientUserParams) (ClientUser, error) {
	row := q.db.QueryRow(ctx, updateClientUser,
		arg.ClientUserID,
		arg.ClientID,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Department,
		arg.Position,
		arg.Settings,
		arg.Status,
	)
	var i ClientUser
	err := row.Scan(
		&i.ClientUserID,
		&i.ClientID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Department,
		&i.Position,
		&i.Settings,
		&i.Status,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
