// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: operators.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOperator = `-- name: CreateOperator :one
INSERT INTO operators (
    operator_id,
    email,
    first_name,
    last_name,
    status,
    mfa_enabled
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING operator_id, email, first_name, last_name, status, mfa_enabled, password_hash, salt, last_login_at, password_changed_at, deleted_at, deleted_by, created_at, updated_at
`

type CreateOperatorParams struct {
	OperatorID pgtype.UUID `json:"operator_id"`
	Email      string      `json:"email"`
	FirstName  string      `json:"first_name"`
	LastName   string      `json:"last_name"`
	Status     string      `json:"status"`
	MfaEnabled bool        `json:"mfa_enabled"`
}

func (q *Queries) CreateOperator(ctx context.Context, arg CreateOperatorParams) (Operator, error) {
	row := q.db.QueryRow(ctx, createOperator,
		arg.OperatorID,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Status,
		arg.MfaEnabled,
	)
	var i Operator
	err := row.Scan(
		&i.OperatorID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.MfaEnabled,
		&i.PasswordHash,
		&i.Salt,
		&i.LastLoginAt,
		&i.PasswordChangedAt,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOperator = `-- name: DeleteOperator :exec
UPDATE operators
SET
    deleted_at = now(),
    deleted_by = $2,
    updated_at = now()
WHERE operator_id = $1
  AND deleted_at IS NULL
`

type DeleteOperatorParams struct {
	OperatorID pgtype.UUID `json:"operator_id"`
	DeletedBy  pgtype.UUID `json:"deleted_by"`
}

func (q *Queries) DeleteOperator(ctx context.Context, arg DeleteOperatorParams) error {
	_, err := q.db.Exec(ctx, deleteOperator, arg.OperatorID, arg.DeletedBy)
	return err
}

const getOperator = `-- name: GetOperator :one
SELECT operator_id, email, first_name, last_name, status, mfa_enabled, password_hash, salt, last_login_at, password_changed_at, deleted_at, deleted_by, created_at, updated_at FROM operators
WHERE operator_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetOperator(ctx context.Context, operatorID pgtype.UUID) (Operator, error) {
	row := q.db.QueryRow(ctx, getOperator, operatorID)
	var i Operator
	err := row.Scan(
		&i.OperatorID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.MfaEnabled,
		&i.PasswordHash,
		&i.Salt,
		&i.LastLoginAt,
		&i.PasswordChangedAt,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOperatorByEmail = `-- name: GetOperatorByEmail :one
SELECT operator_id, email, first_name, last_name, status, mfa_enabled, password_hash, salt, last_login_at, password_changed_at, deleted_at, deleted_by, created_at, updated_at FROM operators
WHERE email = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetOperatorByEmail(ctx context.Context, email string) (Operator, error) {
	row := q.db.QueryRow(ctx, getOperatorByEmail, email)
	var i Operator
	err := row.Scan(
		&i.OperatorID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.MfaEnabled,
		&i.PasswordHash,
		&i.Salt,
		&i.LastLoginAt,
		&i.PasswordChangedAt,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listOperators = `-- name: ListOperators :many
SELECT operator_id, email, first_name, last_name, status, mfa_enabled, password_hash, salt, last_login_at, password_changed_at, deleted_at, deleted_by, created_at, updated_at FROM operators
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOperatorsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListOperators(ctx context.Context, arg ListOperatorsParams) ([]Operator, error) {
	rows, err := q.db.Query(ctx, listOperators, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Operator{}
	for rows.Next() {
		var i Operator
		if err := rows.Scan(
			&i.OperatorID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Status,
			&i.MfaEnabled,
			&i.PasswordHash,
			&i.Salt,
			&i.LastLoginAt,
			&i.PasswordChangedAt,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOperator = `-- name: UpdateOperator :one
UPDATE operators
SET
    email = COALESCE($2, email),
    first_name = COALESCE($3, first_name),
    last_name = COALESCE($4, last_name),
    status = COALESCE($5, status),
    mfa_enabled = COALESCE($6, mfa_enabled),
    last_login_at = COALESCE($7, last_login_at),
    password_changed_at = COALESCE($8, password_changed_at),
    updated_at = now()
WHERE operator_id = $1
  AND deleted_at IS NULL
RETURNING operator_id, email, first_name, last_name, status, mfa_enabled, password_hash, salt, last_login_at, password_changed_at, deleted_at, deleted_by, created_at, updated_at
`

type UpdateOperatorParams struct {
	OperatorID        pgtype.UUID        `json:"operator_id"`
	Email             string             `json:"email"`
	FirstName         string             `json:"first_name"`
	LastName          string             `json:"last_name"`
	Status            string             `json:"status"`
	MfaEnabled        bool               `json:"mfa_enabled"`
	LastLoginAt       pgtype.Timestamptz `json:"last_login_at"`
	PasswordChangedAt pgtype.Timestamptz `json:"password_changed_at"`
}

func (q *Queries) UpdateOperator(ctx context.Context, arg UpdateOperatorParams) (Operator, error) {
	row := q.db.QueryRow(ctx, updateOperator,
		arg.OperatorID,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Status,
		arg.MfaEnabled,
		arg.LastLoginAt,
		arg.PasswordChangedAt,
	)
	var i Operator
	err := row.Scan(
		&i.OperatorID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.MfaEnabled,
		&i.PasswordHash,
		&i.Salt,
		&i.LastLoginAt,
		&i.PasswordChangedAt,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
